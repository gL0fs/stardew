#include "BaseMapLayer.h"
#include "BaseMapLayer.h"
USING_NS_CC;

BaseMapLayer::BaseMapLayer() : _map(nullptr), _playerInstance(nullptr) {
}

BaseMapLayer* BaseMapLayer::create(const std::string& tmxFile)
{
    BaseMapLayer* layer = new (std::nothrow) BaseMapLayer();
    if (layer && layer->initMap(tmxFile))
    {
        layer->autorelease();
        return layer;
    }
    CC_SAFE_DELETE(layer);
    return nullptr;
}

bool BaseMapLayer::init() {
    if (!Layer::init()) {
        return false;
    }
    CCLOG("BaseMapLayer::init() is called!");
    // 设置键盘监听
    initMouseEvent();
    auto keyboardListener = EventListenerKeyboard::create();
    keyboardListener->onKeyPressed = CC_CALLBACK_2(BaseMapLayer::onKeyPressed, this);
    keyboardListener->onKeyReleased = CC_CALLBACK_2(BaseMapLayer::onKeyReleased, this);
    _eventDispatcher->addEventListenerWithSceneGraphPriority(keyboardListener, this);

    // 设置定时器，更新玩家位置
    this->scheduleUpdate();

    return true;
}


bool BaseMapLayer::initMap(const std::string& tmxFile)
{
    if (!init())
    {
        return false;
    }
    loadMap(tmxFile);

    return true;
}

void BaseMapLayer::loadMap(const std::string& tmxFile)
{
    _map = TMXTiledMap::create(tmxFile);
    Size mapSize = _map->getContentSize();
    auto visibleSize = Director::getInstance()->getVisibleSize();
    Vec2 origin = Director::getInstance()->getVisibleOrigin();

    // 将地图放大四倍
    _map->setScale(1.0f);
    
    // 计算地图的新位置，确保地图居中显示
    float scaledWidth = mapSize.width * _map->getScale();
    float scaledHeight = mapSize.height * _map->getScale();
    float x = origin.x + (visibleSize.width - scaledWidth) / 2;
    float y = origin.y + (visibleSize.height - scaledHeight) / 2;
    _map->setPosition(x, y);

    // 添加地图到层
    this->addChild(_map, -1);

    // 初始化视角中心为玩家位置
    if (_playerInstance) {
        setViewPointCenter(_playerInstance->getPosition());
    }
}


void BaseMapLayer::initializePlayer() {

    // 获取玩家单例
    _playerInstance = Player::getInstance();
    // 初始化玩家精灵
    if (!_playerInstance->initPlayer("Player.png")) {
        return;
    }

    // 获取瓦片地图的瓦片尺寸
    auto tileSize = _map->getTileSize();

    // 获取玩家精灵的原始尺寸
    auto playerContentSize = _playerInstance->getContentSize();

    // 计算缩放比例
    // 玩家宽度缩放为地图格子宽度
    float scaleWidth = tileSize.width / playerContentSize.width;
    // 玩家高度缩放为两个地图格子高度
    float scaleHeight = (2 * tileSize.height) / playerContentSize.height;

    // 设置玩家精灵的缩放比例
    _playerInstance->setScale(scaleWidth, scaleHeight);

    // 设置玩家位置
    setPlayerPosition("Objects", "SpawnPoint");

    // 添加玩家精灵到地图层
    this->addChild(_playerInstance);
}

void BaseMapLayer::setPlayerPosition(const std::string& objectGroupName, const std::string& spawnPointName) {
    if (!_map || !_playerInstance) return;

    // 从地图对象组获取出生点
    auto objectGroup = _map->getObjectGroup(objectGroupName);
    if (!objectGroup) return;

    auto spawnPoint = objectGroup->getObject(spawnPointName);
    if (spawnPoint.empty()) return;

    // 设置玩家位置
    float x = spawnPoint["x"].asFloat();
    float y = spawnPoint["y"].asFloat();

    _playerInstance->setPosition(cocos2d::Vec2(x, y));
    setViewPointCenter(_playerInstance->getPosition());
}

//bool BaseMapLayer::isCollisionAtNextPosition(const cocos2d::Vec2& nextPosition) {
//    // 获取障碍物层
//    auto obstacles = _map->getLayer("BackGround"); // 假设障碍物层名为"Obstacles"
//
//
//    if (!obstacles) {
//        // 如果没有障碍物层，则不进行碰撞检测
//        return false;
//    }
//
//    // 获取瓦片大小和地图大小
//    auto tileSize = this->_map->getTileSize();
//    auto mapSize = this->_map->getMapSize();
//
//    // 将下一个位置转换为瓦片坐标
//    int x = nextPosition.x / tileSize.width;
//    int y = (mapSize.height * tileSize.height - nextPosition.y) / tileSize.height;
//    auto tileCoord = cocos2d::Vec2(x, y);
//
//    // 获取该瓦片坐标的GID
//    int GID = obstacles->getTileGIDAt(tileCoord);
//
//    // 如果GID为0，表示该位置没有瓦片，即不是障碍物
//    if (GID == 0) {
//        return false;
//    }
//
//    // 获取瓦片的属性
//    cocos2d::Value properties = _map->getPropertiesForGID(GID);
//    if (properties.getType() == cocos2d::Value::Type::MAP) {
//        cocos2d::ValueMap propMap = properties.asValueMap();
//        // 检查是否有"collidable"属性并且值为true
//        bool collidable = propMap.find("collidable") != propMap.end() && propMap.at("collidable").asBool();
//        return collidable;
//    }
//
//    // 默认不发生碰撞
//    return false;
//}
//

void BaseMapLayer::handlePlayerMovement(const cocos2d::Vec2& direction) {
    if (!_playerInstance) return;

    float moveSpeed = 5.0f;  // 移动速度
    cocos2d::Vec2 nextPosition = _playerInstance->getPosition() + direction * moveSpeed;

    // 添加碰撞检测（如果需要）
    // if (!isCollisionAtNextPosition(nextPosition)) {
    _playerInstance->setPosition(nextPosition);
    this->setViewPointCenter(nextPosition);
    // }
}

void BaseMapLayer::update(float delta) {
    // 添加调试日志
    CCLOG("Move Direction: x=%f, y=%f", _moveDirection.x, _moveDirection.y);

    if (_playerInstance && !_moveDirection.equals(Vec2::ZERO)) {
        handlePlayerMovement(_moveDirection);
    }
}
void BaseMapLayer::onKeyPressed(cocos2d::EventKeyboard::KeyCode keyCode, cocos2d::Event* event) {
    if (!_playerInstance) return;
    CCLOG("Key Pressed: %d", static_cast<int>(keyCode));

    switch (keyCode) {
    case cocos2d::EventKeyboard::KeyCode::KEY_W:
    case cocos2d::EventKeyboard::KeyCode::KEY_UP_ARROW:
        _moveDirection.y = 1;  // 向上移动
        break;
    case cocos2d::EventKeyboard::KeyCode::KEY_S:
    case cocos2d::EventKeyboard::KeyCode::KEY_DOWN_ARROW:
        _moveDirection.y = -1;  // 向下移动
        break;
    case cocos2d::EventKeyboard::KeyCode::KEY_A:
    case cocos2d::EventKeyboard::KeyCode::KEY_LEFT_ARROW:
        _moveDirection.x = -1;  // 向左移动
        break;
    case cocos2d::EventKeyboard::KeyCode::KEY_D:
    case cocos2d::EventKeyboard::KeyCode::KEY_RIGHT_ARROW:
        _moveDirection.x = 1;  // 向右移动
        break;
    }
    //归一化移动方向
    _moveDirection.normalize();
}

void BaseMapLayer::onKeyReleased(cocos2d::EventKeyboard::KeyCode keyCode, cocos2d::Event* event) {
    if (!_playerInstance) return;
    CCLOG("Key Pressed: %d", static_cast<int>(keyCode));

    switch (keyCode) {
    case cocos2d::EventKeyboard::KeyCode::KEY_W:
    case cocos2d::EventKeyboard::KeyCode::KEY_UP_ARROW:
        _moveDirection.y = 0;  // 停止向上移动
        break;
    case cocos2d::EventKeyboard::KeyCode::KEY_S:
    case cocos2d::EventKeyboard::KeyCode::KEY_DOWN_ARROW:
        _moveDirection.y = 0;  // 停止向下移动
        break;
    case cocos2d::EventKeyboard::KeyCode::KEY_A:
    case cocos2d::EventKeyboard::KeyCode::KEY_LEFT_ARROW:
        _moveDirection.x = 0;  // 停止向左移动
        break;
    case cocos2d::EventKeyboard::KeyCode::KEY_D:
    case cocos2d::EventKeyboard::KeyCode::KEY_RIGHT_ARROW:
        _moveDirection.x = 0;  // 停止向右移动
        break;
    }
    //归一化移动方向
    _moveDirection.normalize();
}
void BaseMapLayer::setViewPointCenter(Point position) {
    auto winSize = Director::getInstance()->getWinSize();
    int x = MAX(position.x, winSize.width / 2);
    int y = MAX(position.y, winSize.height / 2);

    x = MIN(x, (_map->getMapSize().width * this->_map->getTileSize().width) - winSize.height / 2);
    y = MIN(y, (_map->getMapSize().height * this->_map->getTileSize().width) - winSize.height / 2);
    auto actualPosition = Point(x, y);

    auto centerOfView = Point(winSize.width / 2, winSize.height / 2);
    auto viewPoint = centerOfView - actualPosition;
    this->setPosition(viewPoint);
}

void BaseMapLayer::initMouseEvent() {
    // 创建鼠标事件监听器
    _mouseListener = cocos2d::EventListenerMouse::create();

    // 设置鼠标点击事件
    _mouseListener->onMouseDown = [this](cocos2d::Event* event) {
        auto mouseEvent = static_cast<cocos2d::EventMouse*>(event);

        // 获取鼠标在OpenGL坐标系中的位置
        cocos2d::Vec2 mouseLocation = mouseEvent->getLocationInView();

        // 转换为世界坐标
        cocos2d::Vec2 worldLocation = this->convertToNodeSpace(mouseLocation);

        // 检查是否可以种树
        if (canPlantTreeAtPosition(worldLocation)) {
            plantTree(worldLocation);
        }
        };

    // 添加事件监听器
    _eventDispatcher->addEventListenerWithSceneGraphPriority(_mouseListener, this);
}
void BaseMapLayer::plantTree(cocos2d::Vec2 position) {
    // 创建树木精灵
    auto treeSprite = cocos2d::Sprite::create("tree1_spring.png");
    // 根据地图瓦片大小调整树的大小
    auto tileSize = _map->getTileSize();
    float scaleX = tileSize.width / treeSprite->getContentSize().width;
    float scaleY = tileSize.height / treeSprite->getContentSize().height;
    treeSprite->setScale(scaleX, scaleY);
    // 设置树木位置（居中于瓦片）
    treeSprite->setPosition(position);
    // 添加到地图
    _map->addChild(treeSprite, 1);  // 确保树在玩家上层
    // 保存到树木vector
    _treesVector.pushBack(treeSprite);
    // 可以添加种树音效
    // CocosDenshion::SimpleAudioEngine::getInstance()->playEffect("plant.wav");
}
bool BaseMapLayer::canPlantTreeAtPosition(cocos2d::Vec2 position) {
    // 获取地图对象组，检查可种植区域
    auto objectGroup = _map->getObjectGroup("PlantArea");
    if (!objectGroup) {
        CCLOG("No PlantArea object group found!");
        return false;
    }

    // 将位置转换到地图的节点坐标系
    Vec2 mapPosition = _map->convertToNodeSpace(position);

    // 遍历可种植区域
    for (auto& plantAreaValue : objectGroup->getObjects()) {
        auto plantArea = plantAreaValue.asValueMap();  // 确保 ValueMap 转换

        float x = plantArea["x"].asFloat();
        float y = plantArea["y"].asFloat();
        float width = plantArea["width"].asFloat();
        float height = plantArea["height"].asFloat();

        cocos2d::Rect plantRect(x, y, width, height);

        // 检查位置是否在可种植区域内
        if (plantRect.containsPoint(mapPosition)) {
            // 检查是否已经有树
            for (auto tree : _treesVector) {
                if (tree && tree->getBoundingBox().intersectsRect(plantRect)) {
                    return false;  // 已经有树了
                }
            }
            return true;  // 可以种植
        }
    }

    return false;  // 不在可种植区域内
}



